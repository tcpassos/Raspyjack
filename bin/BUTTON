#!/usr/bin/env python3
"""BUTTON - Wait for ANY supported Raspyjack button/joystick input.
Usage:
  BUTTON [TIMEOUT] [MESSAGE...]
Examples:
  BUTTON                 # wait indefinitely for any key
  BUTTON 10s Continue    # wait up to 10 seconds
  BUTTON 2m Press something to proceed
Timeout units: ms, s (default), m, h, d (same as WAIT_FOR_KEY).
Exit codes: 0 pressed, 1 timeout, 3 error.
Messages are emitted via SERIAL_WRITE like WAIT_FOR_KEY.
"""
import sys, time, os

# Add main directory to path for centralized GPIO configuration
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from gpio_config import gpio_config

# Load pin mappings from centralized configuration
KEY_NAME_TO_PIN = {
    'UP': gpio_config.key_up_pin,
    'DOWN': gpio_config.key_down_pin,
    'LEFT': gpio_config.key_left_pin,
    'RIGHT': gpio_config.key_right_pin,
    'PRESS': gpio_config.key_press_pin,
    'KEY1': gpio_config.key1_pin,
    'KEY2': gpio_config.key2_pin,
    'KEY3': gpio_config.key3_pin,
}
ALL_PINS = list(set(pin for pin in KEY_NAME_TO_PIN.values() if pin > 0))

PIPE = "/tmp/raspyjack.pipe"

def stat_is_fifo(path: str) -> bool:
    try:
        import stat
        return stat.S_ISFIFO(os.stat(path).st_mode)
    except Exception:
        return False

def write_pipe(msg: str):
    if os.path.exists(PIPE) and stat_is_fifo(PIPE):
        try:
            with open(PIPE, 'w') as f:
                f.write(msg + "\n")
        except Exception:
            pass

def parse_timeout(tok: str):
    if tok is None:
        return None
    t = tok.lower()
    try:
        if t.endswith('ms'): return float(t[:-2]) / 1000.0
        if t.endswith('s'):  return float(t[:-1])
        if t.endswith('m'):  return float(t[:-1]) * 60.0
        if t.endswith('h'):  return float(t[:-1]) * 3600.0
        if t.endswith('d'):  return float(t[:-1]) * 86400.0
        # plain number -> seconds
        return float(t)
    except ValueError:
        return None

def main():
    args = sys.argv[1:]
    timeout = None
    message_start = 0
    if args:
        maybe = parse_timeout(args[0])
        if maybe is not None:
            timeout = maybe
            message_start = 1
    message = " ".join(args[message_start:]) if len(args) > message_start else "Waiting for any button"

    try:
        import RPi.GPIO as GPIO  # type: ignore
    except Exception:
        write_pipe("SERIAL_WRITE: BUTTON GPIO IMPORT ERROR")
        sys.exit(3)

    try:
        GPIO.setmode(GPIO.BCM)
        for p in ALL_PINS:
            GPIO.setup(p, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    except Exception:
        write_pipe("SERIAL_WRITE: BUTTON GPIO SETUP ERROR")
        sys.exit(3)

    write_pipe(f"SERIAL_WRITE: {message}")

    last_state = {p: GPIO.input(p) for p in ALL_PINS}
    start = time.time()
    pressed_key = None
    try:
        while True:
            for name, pin in KEY_NAME_TO_PIN.items():
                try:
                    state = GPIO.input(pin)
                except Exception:
                    continue
                if last_state[pin] == 1 and state == 0:
                    pressed_key = name
                    raise StopIteration
                last_state[pin] = state
            if timeout is not None and (time.time() - start) >= timeout:
                break
            time.sleep(0.05)
    except StopIteration:
        pass

    sys.exit(0 if pressed_key else 1 if timeout is not None else 3)

if __name__ == '__main__':
    main()
